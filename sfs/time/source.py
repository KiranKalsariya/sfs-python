"""Compute the sound field generated by a sound source.

The Green's function describes the spatial sound propagation over time.

.. include:: math-definitions.rst

"""

from __future__ import division
import numpy as np
from scipy.interpolate import interp1d
from .. import util
from .. import defs


def linear_interpolator(x, y):
    """1d linear interpolator with zero-padding.

    Parameters
    ----------
    x : (N,) array_like
        Sampling points.
    y : (N,) array_like
        Values at sampling points.

    Returns
    -------
    function
        Piecewise linear interpolant.

    """
    x = util.asarray_1d(x)
    y = util.asarray_1d(y)
    if len(x) < 3:
        x = np.concatenate([np.array([min(x)-1]), x, np.array([max(x)+1])])
        y = np.concatenate([np.array([0]), y, np.array([0])])
    return interp1d(x, y, bounds_error=False, fill_value=0)


def point(xs, signal, observation_time, grid, c=None,
          interpolator=linear_interpolator):
    r"""Source model for a point source: 3D Green's function.

    Calculates the scalar sound pressure field for a given point in
    time, evoked by source excitation signal.

    Parameters
    ----------
    xs : (3,) array_like
        Position of source in cartesian coordinates.
    signal : tuple of (N,) array_like, followed by 1 or 2 scalars
        Excitation signal consisting of (mono) audio data, sampling rate
        (in Hertz) and optional starting time (in seconds).
    observation_time : float
        Observed point in time.
    grid : triple of array_like
        The grid that is used for the sound field calculations.
        See `sfs.util.xyz_grid()`.
    c : float, optional
        Speed of sound.
    interpolator : function, optional
        A function which constructs and returns a 1d interpolator.
        see: linear_interpolator, sinc_interpolator

    Returns
    -------
    numpy.ndarray
        Scalar sound pressure field, evaluated at positions given by
        *grid*.

    Notes
    -----
    .. math::

        g(x-x_s,t) = \frac{1}{4 \pi |x - x_s|} \dirac{t - \frac{|x -
        x_s|}{c}}

    """
    xs = util.asarray_1d(xs)
    data, samplerate, signal_offset = util.as_delayed_signal(signal)
    data = util.asarray_1d(data)
    grid = util.as_xyz_components(grid)
    if c is None:
        c = defs.c
    r = np.linalg.norm(grid - xs)
    # evaluate g over grid
    weights = 1 / (4 * np.pi * r)
    delays = r / c
    base_time = observation_time - signal_offset
    p_interpolant = interpolator(np.arange(len(data)), data)
    return p_interpolant((base_time - delays) * samplerate) * weights


def sinc_interpolator(x, y):
    x = util.asarray_1d(x)
    y = util.asarray_1d(y)

    def f(xnew):
        return sum([y[i] * np.sinc(xnew - x[i]) for i in range(len(x))])
    return f
